# -*- coding: utf-8 -*-
"""test1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pOO3Jww2Zn6J-rVjf-HwbhvRBptLiYY_
"""

import csv
import pandas as pd
import numpy as np
from pandas import DataFrame

df = pd.read_csv('./test1.csv')
print(df)

# 기본 전처리 : ‘artists’ 값이 없는 데이터를 제거하시오.
basic = df_dropna = df.dropna(subset=['artists']) # 컬럼 'artists'에 결측치가 있는 경우 삭제
print(basic)
basic.head()

# 1-1. 가수별로 등록된 곡수를 집계해보고,
example1 = basic.groupby(basic['artists'])['name'].count()   #가수별로 등록된 곡수 집계
example2 = basic.groupby(basic['artists']).count()
print(example1)

# 1-2. 5곡 이상의 인기곡을 보유한 가수들을 출력하시오.
# example3 = basic.groupby(basic['artists'])['name'].count() >= 5 
example3 = example2.query('name >= 5') # 5곡 이상의 인기곡을 보유한 가수들
# example3 = example2[example2['name']>=5]
example3['name']

#2. Valence 값이 0.5 이상인 곡들에 대해 Danceability와 Energy 변수 간 피어슨 상관계수를 출력하시오.
example4 = basic.query('valence >= 0.5') # alence 값이 0.5 이상인 곡들
corr = lambda p : p['danceability'].corr(p['energy']) # Danceability와 Energy 칼럼 간의 상관관계 
# answer = example4.corr(method='pearson')
answer = corr(example4)
print(answer)

#example4
# corr_a_d = lambda g: g['danceability'].corr(g['energy'])
# grouped = example4.groupby('name')
# DataFrame(grouped.apply(corr_a_d))

# corr = example4.corr(method = 'pearson')
# print(corr)

# 3. ‘danceability’, ‘energy’, ‘loudness’, ‘speechiness’, ‘acousticness’,
# ‘instrumentalness’, ‘liveness’, ‘valence’, ‘tempo’ 의 9개 변수를 사용해
#‘duration_ms’를 예측하는 다중선형회귀 모델을 생성하시오. (학습 데이터는 100개의 데이터를 모두 사용할 것)
from sklearn.model_selection import train_test_split
# from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
from sklearn import linear_model

X_data = basic[['danceability', 'energy', 'loudness', 'speechiness', 'acousticness','instrumentalness', 'liveness', 'valence', 'tempo']]  #9개 변수
Y_data = basic[['duration_ms']]  # 예측할 변수

#다중선형회귀 모델 설계
linear_regression_model = linear_model.LinearRegression() 
linear_regression_model.fit(X = pd.DataFrame(X_data), y = Y_data)
linear_regression_model_prediction = linear_regression_model.predict(X = pd.DataFrame(X_data))

#다중회귀분석 실제값 / 예측값 도식화
fig = plt.figure( figsize = (12, 4))
graph = fig.add_subplot(1,1,1)
graph.plot(Y_data[:88], marker='o', color='blue', label='actual')
graph.plot(linear_regression_model_prediction[:88], marker='^', color='red', label='predict')
graph.set_title('multiple linear regression', size=30)
plt.xlabel('횟수', size=20)
plt.ylabel('duration_ms', size=20)
plt.legend(loc = 'best')

# 예측-실제값 도식화
y_predict = mlr.predict(x_test)
plt.scatter(y_test, y_predict, alpha=0.4)
plt.xlabel("Actual duration_ms")
plt.ylabel("Predicted duration_ms")
plt.title("multiple linear regression")
plt.show()

# 4-1. 가수별로 ‘danceability’, ‘energy’, ‘loudness’, ‘acousticness’, ‘tempo’, ‘duration_ms’ 6개 변수의 평균값을 집계하시오

# 가수별 6개 변수의 평균값 집계
avg = basic.groupby('artists')[['danceability', 'energy', 'loudness', 'acousticness', 'tempo', 'duration_ms']].mean()
avg.head()

# 4-2. 집계된 평균 데이터를 이용하여 K-means Clustering 기법으로 5개 군집으로 분류하시오. 
from sklearn import datasets
import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot  as plt
import seaborn as sns

feature = avg[['energy','tempo']]
model = KMeans(n_clusters=5,algorithm='auto')
model.fit(feature)
predict = pd.DataFrame(model.predict(feature))
predict.columns=['predict']
print(predict)
r = pd.concat([feature,predict],axis=1)
plt.scatter(r['energy'],r['tempo'],c=r['predict'],alpha=0.5)
centers = pd.DataFrame(model.cluster_centers_,columns=['energy','tempo'])
center_x = centers['energy']
center_y = centers['tempo']
plt.scatter(center_x,center_y,s=50,marker='D',c='r')

##########################
x = avg.copy()
kmeans = KMeans(5)
kmeans.fit(x)
print(kmeans.cluster_centers_)
clusters = x.copy()
clusters['cluster_predict'] = kmeans.fit_predict(x)
plt.scatter(clusters['energy'], clusters['tempo'], c=clusters['cluster_predict'], cmap='rainbow')
plt.xlabel('energy')
plt.ylabel('tempo')
plt.show()

##########################
# x = avg.copy()
x = avg.values
kmeans = KMeans(5)
kmeans.fit(x)
print(kmeans.cluster_centers_)
plt.scatter(x[:,0],x[:,1], c=kmeans.labels_)
plt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], s=50, color="red");

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.cluster import KMeans
X = avg.values
# print(avg.values)
kmeans1 = KMeans(n_clusters = 5, init = 'k-means++', random_state = 42)
kmeans1.fit(X)

y_kmeans = kmeans1.fit_predict(X)

plt.scatter(X[y_kmeans == 0, 0], X[y_kmeans == 0, 1], s = 50, c = 'red', label = 'Cluster 1')
plt.scatter(X[y_kmeans == 1, 0], X[y_kmeans == 1, 1], s = 50, c = 'blue', label = 'Cluster 2')
plt.scatter(X[y_kmeans == 2, 0], X[y_kmeans == 2, 1], s = 50, c = 'green', label = 'Cluster 3')
plt.scatter(X[y_kmeans == 3, 0], X[y_kmeans == 3, 1], s = 50, c = 'cyan', label = 'Cluster 4')
plt.scatter(X[y_kmeans == 4, 0], X[y_kmeans == 4, 1], s = 50, c = 'magenta', label = 'Cluster 5')
plt.scatter(kmeans1.cluster_centers_[:, 0], kmeans1.cluster_centers_[:, 1], s = 50, c = 'black', label = 'Centroids')

# 4-3. 또한 군집 분석 결과 aritist명 ‘Sam Smith’와 같은 군집에 속한 가수들을 출력하고
avg['cluster'] = y_kmeans 
avg.head()
is_sam = avg.query('artists == "Sam Smith"')
# is_sam  #sam smith 는 군집 4에 속함을 알 수 있음
sam = avg.query('cluster == 4')
sam

# 4-4. 이 가수들의 Normalized된 평균 Danceability 값의 합을 출력하시오. (Normalization은 Min-Max Scaling이용)
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
sam[ : ] = scaler.fit_transform(sam[ : ])
sam

print("가수들의 Normalized된 평균 Danceability 값의 합 : ",sam['danceability'].sum())